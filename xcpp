#!/usr/bin/env bash

# Copyright (C) 2018-2019 St√©phane Duguay <s@binarez.com>
# This file may be used under the terms of the GNU General Public License, version 2 or later.
# For more details see: https://www.gnu.org/licenses/gpl-2.0.html

# xcpp run -c clang ~~locale="fr" --*boost --options="-O3 -march=native" qweqwe.xcpp

# -h --help | show help
# --version | prints version number at program startup
# -c --compiler | select compiler
# -L --locale
# -n --noboost
# -v --verbose	(
# -m --mode (debug, release, custom, etc.)
# -o --options | compiler options
# -f --force
# -C --config
# -l --less
# -q --quiet
# -r --reverse | reverse compiler output (bottom to top printout)

# xcpp config -> install to /usr/local/bin ou choix du path dans $PATH ou custom, choix compilateur
# xcpp test -> automatically calls the test function of a .xcpp or .xhpp file
# xcpp info
# xcpp show FILE.xhpp or FILE.xcpp -> prints the first comment in the source file

# Stop execution on error
set -e

#----[ Compilers setup ] ------------------------------------------------------------
xcpp_g++ () {
	echo g++ -fdiagnostics-color=always -pipe -xc++ $xcppGccUserOptions -include $xcppIncludeFile -o $xcppElfFile /dev/stdin $xcppFileName
}

xcpp_g++_debug () {
	echo g++ -g -fdiagnostics-color=always -pipe -xc++ $xcppGccUserOptions -include $xcppIncludeFile -o $xcppElfFile /dev/stdin $xcppFileName
}

xcpp_g++_release () {
	echo g++ -O3 -fdiagnostics-color=always -pipe -xc++ $xcppGccUserOptions -include $xcppIncludeFile -o $xcppElfFile /dev/stdin $xcppFileName
}

xcpp_gcc () {
	echo gcc -fdiagnostics-color=always -pipe -xc++ $xcppGccUserOptions -include $xcppIncludeFile -o $xcppElfFile /dev/stdin $xcppFileName -lstdc++
}

xcpp_gcc_debug () {
	echo gcc -g -fdiagnostics-color=always -pipe -xc++ $xcppGccUserOptions -include $xcppIncludeFile -o $xcppElfFile /dev/stdin $xcppFileName -lstdc++
}

xcpp_gcc_release () {
	echo gcc -O3 -fdiagnostics-color=always -pipe -xc++ $xcppGccUserOptions -include $xcppIncludeFile -o $xcppElfFile /dev/stdin $xcppFileName -lstdc++
}

xcpp_clang () {
	echo clang -fdiagnostics-color=always -pipe -lstdc++ -xc++ $xcppGccUserOptions -include $xcppIncludeFile -o $xcppElfFile /dev/stdin $xcppFileName
}

xcpp_clang_debug () {
	echo clang -g -fdiagnostics-color=always -pipe -lstdc++ -xc++ $xcppGccUserOptions -include $xcppIncludeFile -o $xcppElfFile /dev/stdin $xcppFileName
}

xcpp_clang_release () {
	echo clang -O3 -fdiagnostics-color=always -pipe -lstdc++ -xc++ $xcppGccUserOptions -include $xcppIncludeFile -o $xcppElfFile /dev/stdin $xcppFileName
}

#----[ Constants ] ------------------------------------------------------------
readonly xcppVersion=0
readonly xcppVersionRev=8
readonly xcppWatchDelay=1	# Seconds: 1.5 = 1500 ms
readonly xcppUserConfig="~/.xcpp/xcpp.config"
readonly xcppDirectoryConfig="./xcpp.config"

#----[ Variables ] ------------------------------------------------------------
xcppCompilerUserOptions=""
xcppExecutionArgIndex=1
xcppElfFile=""
xcppIncludeFile=""

#----[ Config: default values ] -----------------------------------------------
xcppCfgCompiler="gcc"
xcppCfgMode=""
xcppCfgCompilerOptions=""
xcppCfgVerbose=0
xcppCfgBoost=0
xcppCfgLocale=""
xcppCfgReverse=0
#-------------------------------------------------------------------------------
ProcessXcppGccArgs () {
	i=1;
	for arg in "$@"
	do
		# If the argument starts with a -dash
		if [[ "$arg" =~ ^-.* ]]; then
			xcppGccUserOptions="$xcppGccUserOptions $arg"
		else
			# We're done
			xcppExecutionArgIndex=$i
			return
		fi
		((i=i+1))
	done
	xcppExecutionArgIndex=1
}
#-------------------------------------------------------------------------------
# [$1] optional : elf file name
CreateTempFiles () {
	if [[ -z $1 ]]; then
		xcppElfFile=$(mktemp /tmp/xcpp.XXXXXXXXXXXXXXXX.elf)
	else
		xcppElfFile="$1"
	fi
	xcppIncludeFile=$(mktemp /tmp/xcpp.XXXXXXXXXXXXXXXX.h)
}

#-------------------------------------------------------------------------------
# $1 the char
# $2 number of times the char is repeated
StringOfChar () {
    local fillsize=$2
    local fill=""
    while [[ $fillsize -gt 0 ]]
    do
	    fill="$1${fill}"
        ((fillsize=fillsize-1))
    done
	echo $fill
}

#-------------------------------------------------------------------------------
PrintVersion () {
	echo "xcpp $xcppVersion.$xcppVersionRev"
}

#-------------------------------------------------------------------------------
CmdPrintHelp () {
	PrintVersion
	echo ""
	echo "usage:"
	echo "$0 FILE.xcpp [ARG1 ARG2 ... ARGN]"
	echo ""
	echo "Optionally, specify gcc options:"
	echo "$0 [GCC_OPTIONS] FILE.xcpp [ARG1 ARG2 ... ARGN]"
	echo ""
	echo "For example, to run crunch.xcpp with O3 level and native optimizations:"
	echo "$0 -march=native -O3 crunch.xcpp"
}

#-------------------------------------------------------------------------------
HelpRun () {
	echo "Compiles and executes an xcpp file."
    echo "xcpp run FILE.xcpp"
}

#-------------------------------------------------------------------------------
HelpBuild () {
	echo "Builds an xcpp file into an executable binary."
    echo "xcpp build FILE.xcpp [FILE.out]"
	echo " FILE.out defaults to FILE.xcpp.out if not specified"
}

#-------------------------------------------------------------------------------
HelpWatch () {
	echo "Compiles, executes and monitors changes to an xcpp file."
    echo "xcpp watch FILE.xcpp"
}

#-------------------------------------------------------------------------------
HelpNew () {
	echo "Creates a new xcpp file."
    echo "xcpp new FILE.xcpp [FILE2.xcpp ... FILEN.xcpp]"
}

#-------------------------------------------------------------------------------
HelpExportHeader () {
	echo "Exports a header file containing the xcpp environment."
    echo "xcpp export_h [FILE.h]"
	echo " FILE.h defaults to xcpp.h if not specified"
}

#-------------------------------------------------------------------------------
HelpExportCpp () {
	echo "Exports a single cpp file containing your xcpp program and the xcpp environment. Allows for standalone compilation without xcpp."
    echo "xcpp export INFILE.xcpp OUTFILE.cpp"
}

#-------------------------------------------------------------------------------
GenerateXcppHeader () {
	echo "\
#ifndef _XCPP_HEADER_RESERVED_H_
#define _XCPP_HEADER_RESERVED_H_

#define __XCPP_VERSION__ $xcppVersion

#include <bits/stdc++.h>

using strings = std::vector< std::string >;
using sz = std::size_t;
using ssz = ssize_t;

using i8 = std::int8_t;
using i16 = std::int16_t;
using i32 = std::int32_t;
using i64 = std::int64_t;

using u8 = std::uint8_t;
using u16 = std::uint16_t;
using u32 = std::uint32_t;
using u64 = std::uint64_t;

using f32 = float;
using f64 = double;
using f128 = __float128; // long double?

template <typename T>
inline std::string str(const T & val)
{
	return std::to_string(val);
}

template <std::size_t N>
inline std::string str(const char (&val)[N])
{
	return std::string{ val };
}

template< typename T >
inline bool within( const T & low, const T & value, const T & hi)
{
	return (low <= value) && (value <= hi);
}

template < typename CONTAINER_TYPE, typename VALUE_TYPE >
inline void purge( CONTAINER_TYPE & container, const VALUE_TYPE & value )
{
	container.erase( std::remove( container.begin(), container.end(), value ), container.end() );
}

template < typename CONTAINER_TYPE, typename COMPARE_FUNC >
inline void purge_if( CONTAINER_TYPE & container, const COMPARE_FUNC & func )
{
	container.erase( std::remove_if( container.begin(), container.end(), func ), container.end() );
}

inline int stricmp(const char * a, const char * b)
{
#ifdef _MSC_VER
	return _stricmp(a, b);
#else
	return strcasecmp(a, b);
#endif
}

// trim from start (in place)
inline void ltrim(std::string &s)
{
	s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](int ch) {
		return !std::isspace(ch);
	}));
}

// trim from end (in place)
inline void rtrim(std::string &s)
{
	s.erase(std::find_if(s.rbegin(), s.rend(), [](int ch) {
		return !std::isspace(ch);
	}).base(), s.end());
}

// trim from both ends (in place)
inline void trim(std::string &s)
{
	ltrim(s);
	rtrim(s);
}

inline void to_lower( std::string & s )
{
	std::transform(s.begin(), s.end(), s.begin(), std::ptr_fun<int, int>(std::tolower));
}

inline void to_upper( std::string & s )
{
	std::transform(s.begin(), s.end(), s.begin(), std::ptr_fun<int, int>(std::toupper));
}

inline void newline( void )
{
	std::cout << std::endl;
}

inline void snewline( std::ostream & o )
{
	o << std::endl;
}

template <typename Arg, typename... Args>
inline void sprint(std::ostream & o, Arg&& arg, Args&&... args)
{
    o << std::forward<Arg>(arg);
    (void)(int[]){0, (void(o << std::forward<Args>(args)), 0)...};
}

template <typename CONTAINER_TYPE>
inline void sprint_range(std::ostream & o, const CONTAINER_TYPE & c, char separator = ' ')
{
	auto i{ begin(c) };
	const auto e{ end(c) };
	if( i != e )
	{
		o << *i;
		for( ++i; i != e; ++i )
		{
			o << separator << *i;
		}
	}
}

template <typename Arg, typename... Args>
inline void sprintln(std::ostream & o, Arg&& arg, Args&&... args)
{
	sprint( o, std::forward<Arg>(arg), std::forward<Args>(args)... );
	o << std::endl;
}

template <typename CONTAINER_TYPE>
inline void sprintln_range(std::ostream & o, const CONTAINER_TYPE & c, char separator = ' ')
{
	sprint_range( o, c, separator );
	o << std::endl;
}

template <typename Arg, typename... Args>
inline void print(Arg&& arg, Args&&... args)
{
	sprint( std::cout, std::forward<Arg>(arg), std::forward<Args>(args)... );
}

template <typename Arg, typename... Args>
inline void println(Arg&& arg, Args&&... args)
{
	sprintln( std::cout, std::forward<Arg>(arg), std::forward<Args>(args)... );
}

template <typename CONTAINER_TYPE>
inline void print_range(const CONTAINER_TYPE & c, char separator = ' ')
{
	sprint_range( std::cout, c, separator );
}

template <typename CONTAINER_TYPE>
inline void println_range(const CONTAINER_TYPE & c, char separator = ' ')
{
	sprintln_range( std::cout, c, separator );
}

template <typename Arg, typename... Args>
inline std::string concat(Arg&& arg, Args&&... args)
{
	std::ostringstream ss;
	sprint( ss, std::forward<Arg>(arg), std::forward<Args>(args)... );
	return ss.str();
}

template <typename CONTAINER_TYPE>
inline std::string concat_range(const CONTAINER_TYPE & c, char separator = ' ')
{
	std::ostringstream ss;
	sprint_range( ss, c, separator );
	return ss.str();
}

template <typename Arg, typename... Args>
inline bool sread( std::istream & i, Arg && arg, Args&&... args )
{
	bool ok{ ( i >> std::forward<Arg>(arg) ) };
	if( ok )
	{
		(void)(int[]){0, (void((i >> std::forward<Args>(args)) ? 0 : (ok = false, 0) ), 0)...};
	}
	if( !ok )
	{
		i.clear();
	}
	i.ignore(std::numeric_limits<std::streamsize>::max() - 1, '\n');
	return ok;
}

template <typename Arg, typename... Args>
inline bool read(Arg&& arg, Args&&... args)
{
	return sread( std::cin, std::forward<Arg>(arg), std::forward<Args>(args)... );
}

inline bool sreadln( std::istream & i, std::string & val )
{
	return static_cast< bool >( std::getline( i, val ) );
}

inline bool readln( std::string & val )
{
	return sreadln( std::cin, val );
}

inline void press_enter()
{
	print(\"Press Enter to continue...\");
	std::cin.get();
}

inline void seed_rand( unsigned int seed = 0 )
{
	if( seed == 0 )
	{
		std::srand( static_cast< unsigned int >( std::time( NULL ) ) );
	}
	else
	{
		std::srand( seed );
	}
}

inline void sleep_ms( sz msTime )
{
	std::this_thread::sleep_for( std::chrono::milliseconds(msTime) );
}

using namespace std;

#endif // _XCPP_HEADER_RESERVED_H_ \
" 		> "$1"
}

#-------------------------------------------------------------------------------
OutputXcppMainCpp () {
	echo "\

#include <vector>
#include <string>
/* #include <clocale> */

int main(int _xcpp_reserved_argc_, const char * _xcpp_reserved_argv_[])
{
	/* setlocale( LC_ALL, \"\" ); */
	int $1( std::vector<std::string> );
	return $1( std::vector<std::string>(_xcpp_reserved_argv_ + 1,
										_xcpp_reserved_argv_ + _xcpp_reserved_argc_) );
}\
"
}

#-------------------------------------------------------------------------------
ExecuteXcppBinary () {
	chmod +x "$1"	# Make executable
	"$1" "${@:2}"	# Execute
	return $?
}

#-------------------------------------------------------------------------------
ExtractFunctionName () {
	local funcname=$(basename "$1")
	funcname=${funcname%%.*}
	funcname="${funcname//[^[:alnum:]]/_}"
	echo $funcname
}

#-------------------------------------------------------------------------------
CompileXcpp () {
	local xcppFileName="$1"
	local xcppFunctionName=$(ExtractFunctionName "$1")
	if [[ $xcppCfgVerbose -ne 0 ]]; then
		echo Compiling: $("xcpp_$xcppCfgCompiler")
		local termCols=$(tput cols)
		echo $(StringOfChar "-" $termCols)
	else
		echo -ne "Compiling with $xcppCfgCompiler"
	fi

	set -o pipefail
	if [[ $xcppCfgReverse -ne 0 ]]; then
		OutputXcppMainCpp "$xcppFunctionName" | $("xcpp_$xcppCfgCompiler") 2>&1 | tac
	else
		OutputXcppMainCpp "$xcppFunctionName" | $("xcpp_$xcppCfgCompiler")
	fi
	local compilerRetVal=$?
	set -o pipefail

	echo -ne "\r                                                                   \r"
	return $compilerRetVal
}

#-------------------------------------------------------------------------------
# Runs an xcpp file
# $1 command: run, defrun, spinrun,
# $2 xcpp file to run
CmdRun () {
	if [[ $# -lt 2 ]]; then
		HelpRun
		return
	fi

	ProcessXcppGccArgs "${@:2}"
	((xcppExecutionArgIndex++))

	CreateTempFiles
	# Trap exit for temp files removal and processes termination
	trap "{ rm -f $xcppElfFile; rm -f $xcppIncludeFile; kill 0; }" EXIT
	GenerateXcppHeader $xcppIncludeFile

	CompileXcpp "${!xcppExecutionArgIndex}"
	if [[ $? -eq 0 ]]; then
		if [[ $1 == "runbg" ]]; then
			xcppExitCode=ExecuteXcppBinary "$xcppElfFile" "${@:$xcppExecutionArgIndex}" &
		else
			xcppExitCode=ExecuteXcppBinary "$xcppElfFile" "${@:$xcppExecutionArgIndex}"
		fi
		return $xcppExitCode
	else
		return $?
	fi
}

#-------------------------------------------------------------------------------
# Builds an xcpp file
# $1 command: build, build_*
# $2 xcpp file to build
# [$3] optional : output elf file name
CmdBuild () {
	if [[ $# -lt 2 ]]; then
		HelpBuild
		return
	fi
	local elfToBuild="$3"
	if [[ -z "$elfToBuild" ]]; then
		elfToBuild="./$(basename "$2").out"
	elif [[ -d "$elfToBuild" ]]; then
		elfToBuild="$elfToBuild/$(basename "$2").out"
	fi

	ProcessXcppGccArgs "${@:2}"
	((xcppExecutionArgIndex++))

	CreateTempFiles "$elfToBuild"
	# Trap exit for temp files removal and processes termination
	trap "{ rm -f $xcppIncludeFile; }" EXIT
	GenerateXcppHeader $xcppIncludeFile

	CompileXcpp "${!xcppExecutionArgIndex}"
}

#-------------------------------------------------------------------------------
# [$1] Header file to produce (output): defaults to xcpp.h if not specified
CmdExportHeader () {
	if [[ $# -lt 1 ]]; then
		set -- xcpp.h
		echo xcpp.h
	elif [[ $# -ne 1 ]]; then
		HelpExportHeader;
		return
	fi

	if [[ -f "$1" ]]; then
		echo xcpp error: \""$1"\" already exists, not overwriting.
	else
		GenerateXcppHeader "$1"
	fi
}

#-------------------------------------------------------------------------------
# Export a cpp file from an xcpp file.
# $1 xcpp file (input)
# $2 cpp file (output)
CmdExportCpp () {
	if [[ $# -ne 2 ]]; then
		HelpExportCpp
		return
	elif [[ ! -f "$1" ]]; then
		echo xcpp error: \""$1"\" not found.
	elif [[ -f "$2" ]]; then
		echo xcpp error: \""$2"\" already exists, not overwriting.
	else
		GenerateXcppHeader "$2"
		cat "$1" >> "$2"
		OutputXcppMainCpp $(ExtractFunctionName "$1") >> "$2"
	fi
}

#-------------------------------------------------------------------------------
# Kills a process and deletes temp files
# $1 PID
StopProcess () {
	if ps -p "$1" | grep -q 'xcpp'; then
		kill -9 $1 &> /dev/null
	fi
	rm -f "$xcppElfFile"
	xcppElfFile=""
	rm -f "$xcppIncludeFile"
	xcppIncludeFile=""
}

#-------------------------------------------------------------------------------
# Observe an xcpp file and re-runs it on change.
# $1 watch command (watch or watch_*)
# $2 xcpp file to watch
CmdWatch () {
	if [[ $# -lt 2 ]]; then
		HelpWatch
		return
	fi
	set +e
	local lastHash=`sha256sum "$2"`
	CmdRun runbg "${@:2}"
	local watchedPID=$!
	while true; do
	  sleep $xcppWatchDelay
	  local newHash=`sha256sum "$2"`
	  if [ "$newHash" != "$lastHash" ]; then
		clear
		disown &> /dev/null
		StopProcess $watchedPID
		CmdRun runbg "${@:2}"
		watchedPID=$!
		lastHash="$newHash"
	  fi
	done
}

#-------------------------------------------------------------------------------
CmdNewXcppFiles () {
	if [[ $# -lt 1 ]]; then
		HelpNew
		return
	fi

	for file in "$@"
	do
		if [[ -f "$file" ]]; then
			echo xcpp error: \""$file"\" already exists, not overwriting.
			continue
		fi
		local xcppFunctionName=$(ExtractFunctionName "$file")
		echo "\
#if !defined(__XCPP__)
#define __XCPP__ $xcppVersion
#elif defined(__XCPP__)
#pragma once
#else
. xcpp run \"\$0\" \"\$@\"
#endif

int $xcppFunctionName( strings args )
{
	println( \"Hello, world!\" );
	return 0;
}\
" 		> "$file"
	done
}

#-------------------------------------------------------------------------------
# $1 Config file name
LoadConfigFile () {
. $1
}

#-------------------------------------------------------------------------------
# $1 variable name
EchoVarAndValue () {
	local varName="$1"
	echo "$varName": ${!varName}
}
#-------------------------------------------------------------------------------
PrintConfig () {
	EchoVarAndValue xcppCfgCompiler
	type $"xcpp_$xcppCfgCompiler"
	EchoVarAndValue xcppCfgMode
	EchoVarAndValue xcppCfgCompilerOptions
	EchoVarAndValue xcppCfgVerbose
	EchoVarAndValue xcppCfgBoost
	EchoVarAndValue xcppCfgLocale
}

#-------------------------------------------------------------------------------
LoadConfig () {
	if [[ -f "$xcppUserConfig" ]]; then
		LoadConfigFile "$xcppUserConfig"
	fi
	if [[ -f "$xcppDirectoryConfig" ]]; then
		LoadConfigFile "$xcppDirectoryConfig"
	fi
}

#-------------------------------------------------------------------------------
Main() {
	if [[ $# -lt 1 ]] || [[ $1 == "-h" ]] || [[ $1 == "--help" ]] || [[ $1 == "help" ]]; then
		CmdPrintHelp
		exit 0
	fi

	LoadConfig
	if [[ $xcppCfgVerbose -ne 0 ]]; then
		echo "Verbose enabled"
		PrintVersion
		PrintConfig
	fi

	if [[ $1 == "run" ]]; then
		CmdRun "$@"
		exit $?
	elif [[ $1 == "watch" ]]; then
		CmdWatch "$@"
	elif [[ $1 == "build" ]]; then
		CmdBuild "$@"
		exit $?
	elif [[ $1 == "new" ]]; then
		CmdNewXcppFiles "${@:2}"
	elif [[ $1 == "export" ]]; then
		CmdExportCpp "${@:2}"
	elif [[ $1 == "export_h" ]]; then
		CmdExportHeader "${@:2}"
	else
		echo "xcpp error: unknown subcommand ($1)"
		echo "try 'xcpp help'"
		exit 42
	fi
}

Main "$@"
exit 0
